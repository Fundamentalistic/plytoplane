# Описание предпускового тестирования модуля plytoplane

## Тестирование связных точек
Имеется гипотеза, согласно которой количество связных точек для каждой текущей точки не может быть больше 6. 

### Реализация

Входные данные: массив точек, массив треугольников. Каждый треугольник представляет собой 3 идентификатора точки. Следовательно имеем следующие структуры данных

```C++

typedef struct {
    double x; double y; double z;
} point; // Представление точки

// N размер массива точек
point * points = (point*)malloc(sizeof(point) * N)

typedef struct {
    int a; int b; int c;
} triangle; // Представление треугольника в виде индексов точек

// M размер массива треугольников
triangle * triangles = (triangle*)malloc(sizeof(triangle) * M)
```
В рамках текущего теста мы хотим знать число соседних точек. Точка A является соседом точки B, обозначается $A-B$, если $\exist \triangle : A_{id} \in \triangle \; \land B_{id} \in \triangle$. Если точка присутствует в треугольнике, следовательно обе другие точки являются ее соседями. Если создается множество с лишь уникальными идентификаторами, то перебор по всем треугольникам с добавлением в множество для каждого треугольника. Следовательно имея массив точек и массив треугольников выполним полный перебор по множеству треугольников
```C++

// Создание структуры данных о соседях конкретной точки
// в виде массива эквивалентного индексации точек

std::set<int> * nvrs = new std::set<int>[M];

// Полный перебор по всем треугольникам
for( int i = 0; i < M; i++ ){
    // Для каждой точки в треугольнике обновляем 
    // список соседей остальными точками 
    int p1id = triangles[i]->a;
    int p2id = triangles[i]->b;
    int p3id = triangles[i]->c;

    // Выполняем обновление списка соседей

    nbrs[p1id]->insert(p2id);
    nbrs[p1id]->insert(p3id);

    nbrs[p2id]->insert(p1id);
    nbrs[p2id]->insert(p3id);

    nbrs[p3id]->insert(p2id);
    nbrs[p3id]->insert(p1id);

}

// Проверка на то, что количество соседей не больше 6 
for( int i = 0; i < M; i++ ){
    if ( nbrs[i].size() > 6 ) {
        printf("TestFailed: neighbours size more than 6 for id %i\n", i);
        exit();
    }
}
```

Результаты тестирования показали, что для модели 1fvm.ply существует следующая статистика по соседним точкам 
```
Количество соседей: 7  встречаемость: 15378
Количество соседей: 8  встречаемость: 985
Количество соседей: 9  встречаемость: 5
Количество соседей: 10 встречаемость: 1
```
Следовательно гипотеза о максимальном количестве соседей равным 6 не верна.

В процессе тестирования было выяслено что подобная процедура используется в трехмерной графике для наложения текстур на поверхность и называется UV mapping. В первом приближении видны особенности метода, которые не позволят использовать его в текущем виде для достижения цели. По этому было решено отработать этот метод и адаптировать его к текущей задаче

## Тестирование преобразования координат к сферическим

Формулы перевода декартовых координат к сферическим
$$
r = \sqrt{x^ 2 + y^2 + z^2}\\
\theta = \arccos{\frac{z}{r}}\\
\phi = \arctg{\frac{y}{x}}
$$
Предполагается что примерно сферические объекты будут отлично разворачиваться на плоскость преобразованием к сферическим координатам


